name: Deploy Tools to EKS

on:
  workflow_dispatch:
    inputs:
      tool:
        description: 'Tool to deploy'
        required: true
        type: choice
        options:
          - all
          - prometheus
          - grafana
          - alertmanager
          - elasticsearch
          - kibana
          - filebeat
          - nginx-ingress
          - jenkins
          - cloudwatch-monitoring
          - external-dns
      action:
        description: 'Action'
        required: true
        type: choice
        options:
          - install
          - uninstall

env:
  AWS_REGION: us-east-1
  EKS_CLUSTER_NAME: ticket-booking-eks

jobs:
  deploy:
    name: Deploy ${{ github.event.inputs.tool }}
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
          kubectl get nodes
      
      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: 'latest'

      - name: Install eksctl
        run: |
          ARCH=amd64
          PLATFORM=$(uname -s)_$ARCH
          curl -sLO "https://github.com/eksctl-io/eksctl/releases/latest/download/eksctl_$PLATFORM.tar.gz"
          tar -xzf eksctl_$PLATFORM.tar.gz -C /tmp && rm eksctl_$PLATFORM.tar.gz
          sudo mv /tmp/eksctl /usr/local/bin
          eksctl version
      
      - name: Deploy Prometheus
        if: github.event.inputs.tool == 'prometheus' || github.event.inputs.tool == 'all'
        continue-on-error: true
        run: |
          cd monitoring/prometheus
          helm dependency update
          if [ "${{ github.event.inputs.action }}" == "install" ]; then
            helm upgrade --install prometheus . -n monitoring --create-namespace -f values.yaml --wait
            echo "âœ… Prometheus deployed"
          else
            helm uninstall prometheus -n monitoring || true
            echo "ðŸ—‘ï¸ Prometheus removed"
          fi
      
      - name: Deploy Grafana
        if: github.event.inputs.tool == 'grafana' || github.event.inputs.tool == 'all'
        continue-on-error: true
        run: |
          cd monitoring/grafana
          helm dependency update
          if [ "${{ github.event.inputs.action }}" == "install" ]; then
            helm upgrade --install grafana . -n monitoring --create-namespace -f values.yaml --wait
            echo "âœ… Grafana deployed"
            kubectl get svc -n monitoring grafana
          else
            helm uninstall grafana -n monitoring || true
            echo "ðŸ—‘ï¸ Grafana removed"
          fi
      
      - name: Deploy Alertmanager
        if: github.event.inputs.tool == 'alertmanager' || github.event.inputs.tool == 'all'
        continue-on-error: true
        run: |
          cd monitoring/alertmanager
          helm dependency update
          if [ "${{ github.event.inputs.action }}" == "install" ]; then
            helm upgrade --install alertmanager . -n monitoring --create-namespace -f values.yaml --wait
            echo "âœ… Alertmanager deployed"
          else
            helm uninstall alertmanager -n monitoring || true
            echo "ðŸ—‘ï¸ Alertmanager removed"
          fi

      - name: Deploy CloudWatch Monitoring
        if: github.event.inputs.tool == 'cloudwatch-monitoring' || github.event.inputs.tool == 'all'
        continue-on-error: true
        run: |
          if [ "${{ github.event.inputs.action }}" == "install" ]; then
            echo "ðŸš€ Installing CloudWatch Container Insights..."
            cd monitoring/cloudwatch
            chmod +x install-addon.sh
            ./install-addon.sh
            echo "âœ… CloudWatch Monitoring deployed"
          else
            echo "ðŸ—‘ï¸ Removing CloudWatch Monitoring..."
            aws eks delete-addon --cluster-name ${{ env.EKS_CLUSTER_NAME }} --addon-name amazon-cloudwatch-observability --region ${{ env.AWS_REGION }} || true
            kubectl delete namespace amazon-cloudwatch || true
            echo "âœ… CloudWatch Monitoring removed"
          fi
      
      - name: Deploy Elasticsearch
        if: github.event.inputs.tool == 'elasticsearch' || github.event.inputs.tool == 'all'
        continue-on-error: true
        run: |
          cd logging/elasticsearch
          helm dependency update
          if [ "${{ github.event.inputs.action }}" == "install" ]; then
            helm upgrade --install elasticsearch . -n logging --create-namespace -f values.yaml --wait
            echo "âœ… Elasticsearch deployed"
          else
            helm uninstall elasticsearch -n logging || true
            echo "ðŸ—‘ï¸ Elasticsearch removed"
          fi
      
      - name: Deploy Kibana
        if: github.event.inputs.tool == 'kibana' || github.event.inputs.tool == 'all'
        continue-on-error: true
        run: |
          cd logging/kibana
          helm dependency update
          if [ "${{ github.event.inputs.action }}" == "install" ]; then
            echo "â³ Waiting 60s for Elasticsearch to initialize..."
            sleep 60
            helm upgrade --install kibana . -n logging --create-namespace -f values.yaml --wait --timeout 5m
            echo "âœ… Kibana deployed"
            kubectl get svc -n logging kibana
          else
            helm uninstall kibana -n logging || true
            echo "ðŸ—‘ï¸ Kibana removed"
          fi
      
      - name: Deploy Filebeat
        if: github.event.inputs.tool == 'filebeat' || github.event.inputs.tool == 'all'
        continue-on-error: true
        run: |
          cd logging/filebeat
          helm dependency update
          if [ "${{ github.event.inputs.action }}" == "install" ]; then
            helm upgrade --install filebeat . -n logging --create-namespace -f values.yaml --wait
            echo "âœ… Filebeat deployed"
          else
            helm uninstall filebeat -n logging || true
            echo "ðŸ—‘ï¸ Filebeat removed"
          fi
      
      - name: Deploy Nginx Ingress
        if: github.event.inputs.tool == 'nginx-ingress' || github.event.inputs.tool == 'all'
        continue-on-error: true
        run: |
          cd ingress/nginx-ingress
          helm dependency update
          if [ "${{ github.event.inputs.action }}" == "install" ]; then
            helm upgrade --install nginx-ingress . -n ingress-nginx --create-namespace -f values.yaml --wait
            echo "âœ… Nginx Ingress deployed"
            kubectl get svc -n ingress-nginx
          else
            helm uninstall nginx-ingress -n ingress-nginx || true
            echo "ðŸ—‘ï¸ Nginx Ingress removed"
          fi
      
      - name: Deploy MongoDB
        if: (github.event.inputs.tool == 'jenkins' || github.event.inputs.tool == 'all') && github.event.inputs.action == 'install'
        run: |
          echo "ðŸ“¦ Installing MongoDB in dev namespace..."
          helm repo add bitnami https://charts.bitnami.com/bitnami
          helm repo update
          
          # Check if MongoDB is already installed
          if helm list -n dev | grep -q mongodb; then
            echo "âœ… MongoDB already installed, upgrading..."
            helm upgrade mongodb bitnami/mongodb --namespace dev --set auth.rootPassword=password123
          else
            echo "ðŸ“¥ Installing MongoDB for the first time..."
            helm install mongodb bitnami/mongodb --namespace dev --create-namespace --set auth.rootPassword=password123
          fi
          
          echo "â³ Waiting for MongoDB to be ready..."
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=mongodb -n dev --timeout=120s || echo "âš ï¸  MongoDB may still be starting..."
          echo "âœ… MongoDB installation complete"
      
      - name: Deploy Monitoring Stack (Loki + Grafana + Istio + Kiali)
        if: (github.event.inputs.tool == 'jenkins' || github.event.inputs.tool == 'all') && github.event.inputs.action == 'install'
        run: |
          echo "ðŸ“Š Installing Monitoring Stack..."
          echo "This will install: Loki, Grafana, Prometheus, Istio, and Kiali"
          echo ""
          
          # Add Helm repos
          helm repo add grafana https://grafana.github.io/helm-charts
          helm repo add istio https://istio-release.storage.googleapis.com/charts
          helm repo update
          
          # Install Loki Stack (Loki + Grafana + Prometheus + Promtail)
          echo "ðŸ“Š Installing Loki Stack (Grafana + Loki + Prometheus)..."
          helm upgrade --install loki grafana/loki-stack \
            --namespace monitoring \
            --create-namespace \
            --set grafana.enabled=true \
            --set prometheus.enabled=true \
            --set promtail.enabled=true \
            --set grafana.adminPassword=admin \
            --set grafana.service.type=ClusterIP \
            --set grafana.persistence.enabled=false \
            --set loki.persistence.enabled=false \
            --set prometheus.server.persistentVolume.enabled=false \
            --wait --timeout 10m
          
          echo "âœ… Loki Stack installed"
          
          # Install Istio
          echo "ðŸ“Š Installing Istio..."
          kubectl create namespace istio-system --dry-run=client -o yaml | kubectl apply -f -
          
          helm upgrade --install istio-base istio/base \
            -n istio-system \
            --set defaultRevision=default \
            --wait --timeout 5m
          
          helm upgrade --install istiod istio/istiod \
            -n istio-system \
            --wait --timeout 10m
          
          echo "âœ… Istio installed"
          
          # Install Kiali
          echo "ðŸ“Š Installing Kiali..."
          kubectl apply -f https://raw.githubusercontent.com/istio/istio/release-1.20/samples/addons/kiali.yaml
          
          echo "â³ Waiting for Kiali to be ready..."
          kubectl wait --for=condition=available --timeout=300s deployment/kiali -n istio-system || echo "âš ï¸ Kiali may still be starting"
          
          echo "âœ… Kiali installed"
          
          # Install Jaeger (optional - for distributed tracing)
          echo "ðŸ“Š Installing Jaeger..."
          kubectl apply -f https://raw.githubusercontent.com/istio/istio/release-1.20/samples/addons/jaeger.yaml || echo "âš ï¸ Jaeger installation skipped"
          
          echo ""
          echo "=========================================="
          echo "âœ… Monitoring Stack Installation Complete!"
          echo "=========================================="
          echo ""
          echo "Installed components:"
          echo "  âœ… Loki (Log aggregation)"
          echo "  âœ… Grafana (Visualization) - Port 3000"
          echo "  âœ… Prometheus (Metrics) - Port 9090"
          echo "  âœ… Promtail (Log collector)"
          echo "  âœ… Istio (Service mesh)"
          echo "  âœ… Kiali (Traffic visualization) - Port 20001"
          echo "  âœ… Jaeger (Distributed tracing) - Port 16686"
          echo ""
          echo "âš ï¸  Note: Using ephemeral storage (no persistence)"
          echo "    Logs are collected in real-time but not saved after pod restart"
          echo "    This saves costs - no EBS volumes created"
          echo ""
          echo "To access locally:"
          echo "  Run: ./start-monitoring.sh"
          echo "  Or manually:"
          echo "    kubectl port-forward -n monitoring svc/loki-grafana 3000:80"
          echo "    kubectl port-forward -n istio-system svc/kiali 20001:20001"
          echo "    kubectl port-forward -n monitoring svc/loki-prometheus-server 9090:80"
          echo ""
          
          # Show pod status
          echo "Monitoring pods:"
          kubectl get pods -n monitoring
          kubectl get pods -n istio-system
      
      - name: Deploy Jenkins (Post-Approval)
        if: (github.event.inputs.tool == 'jenkins' || github.event.inputs.tool == 'all') && github.event.inputs.action == 'install'
        run: |
          echo "âœ… Approval confirmed â€” deploying Jenkins"
          echo "Run credentials script first: ./tools/cicd/jenkins/credentials.sh"
          cd cicd/jenkins
          helm dependency update
          
          # Cleanup stuck releases if any
          if helm status jenkins -n jenkins > /dev/null 2>&1; then
            STATUS=$(helm status jenkins -n jenkins -o json | jq -r .info.status)
            echo "Current release status: $STATUS"
            if [ "$STATUS" == "pending-install" ] || [ "$STATUS" == "pending-upgrade" ] || [ "$STATUS" == "pending-rollback" ] || [ "$STATUS" == "failed" ]; then
              echo "âš ï¸ Release is in stuck state ($STATUS). Cleaning up..."
              
              # Try rollback first
              echo "Attempting rollback..."
              helm rollback jenkins -n jenkins --wait --timeout=2m || {
                echo "Rollback failed, forcing cleanup..."
                # Delete the release secret to force cleanup
                kubectl delete secret -n jenkins -l owner=helm,name=jenkins || true
                # Uninstall
                helm uninstall jenkins -n jenkins --wait --timeout=2m || true
              }
              
              # Wait a bit for cleanup
              sleep 10
            fi
          fi

          # Install without atomic (atomic can cause stuck states)
          echo "Installing/Upgrading Jenkins..."
          helm upgrade --install jenkins . -n jenkins --create-namespace -f values.yaml --wait --timeout 10m
          
          kubectl apply -f jenkins-rbac.yaml
          echo "âœ… Jenkins deployed with RBAC permissions"
          kubectl get svc -n jenkins jenkins
      
      - name: Deploy DuckDNS Updater
        if: (github.event.inputs.tool == 'jenkins' || github.event.inputs.tool == 'all') && github.event.inputs.action == 'install'
        run: |
          echo "ðŸ¦† Deploying DuckDNS Updater..."
          kubectl apply -f dns/duckdns-updater.yaml
          # Trigger immediately
          kubectl create job --from=cronjob/duckdns-updater duckdns-init-trigger -n jenkins || true
          echo "âœ… DuckDNS Updater deployed and triggered"
          
          echo ""
          echo "=========================================="
          echo "ðŸŽ‰ Jenkins Deployment Complete!"
          echo "=========================================="
          echo ""
          echo "ðŸ“‹ Access Information:"
          echo "   URL: http://jenkins007.duckdns.org:8080"
          echo "   Username: admin"
          echo "   Password: admin"
          echo ""
          echo "â³ Note: Wait 2-5 minutes for DNS to propagate"
          echo ""
      
      - name: Deploy ArgoCD
        if: (github.event.inputs.tool == 'jenkins' || github.event.inputs.tool == 'all') && github.event.inputs.action == 'install'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ðŸ™ Deploying ArgoCD..."
          
          # Add ArgoCD Helm repo
          helm repo add argo https://argoproj.github.io/argo-helm
          helm repo update
          
          # Create namespace
          kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -
          
          # Get values.yaml from argocd repo
          curl -sSL -o /tmp/argocd-values.yaml \
            https://raw.githubusercontent.com/test-booking-application/argocd/main/values.yaml
          
          # Install ArgoCD
          helm upgrade --install argocd argo/argo-cd \
            --namespace argocd \
            --version 5.51.6 \
            -f /tmp/argocd-values.yaml \
            --wait \
            --timeout 10m
          
          echo "âœ… ArgoCD installed successfully!"
          
          # Get Admin Password
          PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          echo ""
          echo "ðŸ” ArgoCD Admin Password: $PASSWORD"
          
          # Deploy DuckDNS Updater for ArgoCD
          echo ""
          echo "ðŸ¦† Deploying ArgoCD DuckDNS Updater..."
          kubectl apply -f dns/duckdns-updater-argocd.yaml
          # Trigger immediately
          kubectl create job --from=cronjob/duckdns-updater-argocd duckdns-argocd-init-trigger -n argocd || true
          echo "âœ… ArgoCD DuckDNS Updater deployed"
          
          # Deploy Applications (App of Apps)
          echo ""
          echo "ðŸš€ Deploying Microservices (ArgoCD Apps)..."
          
          # Download and apply each application manifest
          mkdir -p /tmp/argocd-apps
          
          curl -sSL -H "Authorization: token ${GITHUB_TOKEN}" -o /tmp/argocd-apps/frontend-app.yaml \
            https://raw.githubusercontent.com/test-booking-application/argocd/main/argocd-applications/frontend-app.yaml
          curl -sSL -H "Authorization: token ${GITHUB_TOKEN}" -o /tmp/argocd-apps/ticket-service-app.yaml \
            https://raw.githubusercontent.com/test-booking-application/argocd/main/argocd-applications/ticket-service-app.yaml
          curl -sSL -H "Authorization: token ${GITHUB_TOKEN}" -o /tmp/argocd-apps/user-service-app.yaml \
            https://raw.githubusercontent.com/test-booking-application/argocd/main/argocd-applications/user-service-app.yaml
          curl -sSL -H "Authorization: token ${GITHUB_TOKEN}" -o /tmp/argocd-apps/booking-service-app.yaml \
            https://raw.githubusercontent.com/test-booking-application/argocd/main/argocd-applications/booking-service-app.yaml
          curl -sSL -H "Authorization: token ${GITHUB_TOKEN}" -o /tmp/argocd-apps/api-gateway-app.yaml \
            https://raw.githubusercontent.com/test-booking-application/argocd/main/argocd-applications/api-gateway-app.yaml
          
          # Apply all application manifests
          kubectl apply -f /tmp/argocd-apps/ -n argocd
          
          echo "âœ… All Applications deployed to ArgoCD!"
          
          echo ""
          echo "=========================================="
          echo "ðŸŽ‰ ArgoCD Deployment Complete!"
          echo "=========================================="
          echo ""
          echo "ðŸ“‹ Access Information:"
          echo "   URL: http://argocd007.duckdns.org"
          echo "   Username: admin"
          echo "   Password: $PASSWORD"
          echo ""
          echo "â³ Note: Wait 2-5 minutes for DNS to propagate"
          echo ""
      
      - name: Configure GitHub Webhooks
        if: (github.event.inputs.tool == 'jenkins' || github.event.inputs.tool == 'all') && github.event.inputs.action == 'install'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ðŸ”— Configuring GitHub webhooks..."
          cd cicd/jenkins
          chmod +x update-github-webhooks.sh
          ./update-github-webhooks.sh
          echo "âœ… Webhooks configured successfully"
      
      - name: Uninstall Jenkins
        if: (github.event.inputs.tool == 'jenkins' || github.event.inputs.tool == 'all') && github.event.inputs.action == 'uninstall'
        run: |
          helm uninstall jenkins -n jenkins || true
          kubectl delete -f cicd/jenkins/jenkins-rbac.yaml || true
          echo "ðŸ—‘ï¸ Jenkins removed"
      
      - name: Uninstall Monitoring Stack
        if: (github.event.inputs.tool == 'jenkins' || github.event.inputs.tool == 'all') && github.event.inputs.action == 'uninstall'
        run: |
          echo "ðŸ—‘ï¸ Removing Monitoring Stack..."
          
          # Uninstall Kiali and Jaeger
          kubectl delete -f https://raw.githubusercontent.com/istio/istio/release-1.20/samples/addons/kiali.yaml || true
          kubectl delete -f https://raw.githubusercontent.com/istio/istio/release-1.20/samples/addons/jaeger.yaml || true
          
          # Uninstall Istio
          helm uninstall istiod -n istio-system || true
          helm uninstall istio-base -n istio-system || true
          kubectl delete namespace istio-system || true
          
          # Uninstall Loki Stack
          helm uninstall loki -n monitoring || true
          kubectl delete namespace monitoring || true
          
          echo "âœ… Monitoring Stack removed"
      
      - name: Deploy ExternalDNS
        if: github.event.inputs.tool == 'external-dns' || github.event.inputs.tool == 'all'
        run: |
          if [ "${{ github.event.inputs.action }}" == "install" ]; then
            echo "ðŸš€ Installing ExternalDNS..."
            helm repo add external-dns https://kubernetes-sigs.github.io/external-dns/
            helm repo update
            cd dns/external-dns
            helm upgrade --install external-dns external-dns/external-dns \
              -n external-dns \
              -f values.yaml \
              --wait --timeout 5m
            echo "âœ… ExternalDNS deployed"
            kubectl get pods -n external-dns
          else
            helm uninstall external-dns -n external-dns || true
            echo "ðŸ—‘ï¸ ExternalDNS removed"
          fi
      
      - name: Display Access Information
        if: github.event.inputs.action == 'install'
        run: |
          echo "========================================="
          echo "Tool Deployment Complete!"
          echo "========================================="
          echo ""
          echo "ðŸ“Š Access Grafana:"
          kubectl get svc -n monitoring grafana 2>/dev/null || echo "Not deployed"
          echo "   Username: admin"
          echo "   Password: admin"
          echo ""
          echo "ðŸ“Š Access CloudWatch:"
          echo "   Dashboard: https://console.aws.amazon.com/cloudwatch/home?region=${{ env.AWS_REGION }}#container-insights:infrastructure"
          echo ""
          echo "ðŸ“Š Access Kibana:"
          kubectl get svc -n logging kibana 2>/dev/null || echo "Not deployed"
          echo ""
          echo "ðŸŒ Ingress LoadBalancer:"
          kubectl get svc -n ingress-nginx 2>/dev/null || echo "Not deployed"
          echo ""
          echo "ðŸš€ Access Jenkins:"
          kubectl get svc -n jenkins jenkins 2>/dev/null || echo "Not deployed"
          echo "   Username: admin"
          echo "   Password: admin"
          echo ""
          echo "ðŸ’¡ Tip: Use port-forward for consistent localhost access:"
          echo "   kubectl port-forward svc/grafana 3000:80 -n monitoring"
          echo "   kubectl port-forward svc/jenkins 8080:8080 -n jenkins"
